<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>本地存储</title>
      <link href="/post/5cb41814.html"/>
      <url>/post/5cb41814.html</url>
      
        <content type="html"><![CDATA[<p><strong>目标：</strong></p><ol><li>能够写出sessionStorge数据的存储以及获取</li><li>能够写出localStorage数据的存储以及获取</li><li>能够说出它们两者的区别</li></ol><h1 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h1><p>随着互联网的快速发展，基于网页的应用越来越普遍，同时也变得越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。</p><p><strong>本地存储特性</strong></p><ol><li>数据存储在用户浏览器中</li><li>设置、读取方便、甚至页面刷新不丢失数据</li><li>容量较大，sessionStorage约5M，localStorage约20M</li><li>只能存储字符串，可以将对象JSON.stringify()编码后存储</li></ol><h1 id="window-sessionStorage"><a href="#window-sessionStorage" class="headerlink" title="window.sessionStorage"></a>window.sessionStorage</h1><ol><li>生命周期未关闭浏览器窗口</li><li>在同一个窗口下数据可以共享</li><li>以键值对的形式存储使用</li></ol><p><strong>存储数据</strong></p><pre><code>sessionStroage.setItem(value,key)</code></pre><p><strong>获取数据</strong></p><pre><code>sessionStroage.getItem(key)</code></pre><p><strong>删除数据</strong></p><pre><code>sessionStroage.removeItem(key)</code></pre><p><strong>删除所有数据</strong></p><pre><code>sessionStroage.clear()</code></pre><h1 id="window-localStorage"><a href="#window-localStorage" class="headerlink" title="window.localStorage"></a>window.localStorage</h1><ol><li>生命周期永久生效，除非手动删除，否则页面关闭也会存在</li><li>可以多窗口共享</li><li>以键值对的方式存储使用</li></ol><p><strong>存储数据</strong></p><pre><code>localStorage.setItem(key,value)</code></pre><p><strong>获取数据</strong></p><pre><code>localStorage.getItem(key)</code></pre><p><strong>删除数据</strong></p><pre><code>localStorage.removeItem(key)</code></pre><p><strong>删除所有数据</strong></p><pre><code>localStorage.clear()</code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> BOM </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PC端网页特效</title>
      <link href="/post/b70e4979.html"/>
      <url>/post/b70e4979.html</url>
      
        <content type="html"><![CDATA[<p><strong>目标</strong></p><ul><li>能够说出常见的offset系列属性的作用</li><li>能够说出常见的client系列属性的作用</li><li>能够说出常见的scroll系列属性的作用</li><li>能够封装简单的动画函数</li><li>能够写出网页轮播图案例</li></ul><h1 id="元素偏移量offset系列"><a href="#元素偏移量offset系列" class="headerlink" title="元素偏移量offset系列"></a>元素偏移量offset系列</h1><p>offset翻译过来就是偏移量，使用offset系列相关属性可以动态的得到该元素的位置（偏移量）、大小等。 <strong>常用于获取元素的位置</strong></p><ul><li>获得元素距离带有定位父元素的位置</li><li>获得元素自身的大小（宽度高度）</li><li>注意：返回的数值都不带单位</li></ul><h2 id="offset系列常用的属性"><a href="#offset系列常用的属性" class="headerlink" title="offset系列常用的属性"></a>offset系列常用的属性</h2><pre><code>element.offsetParent  返回该元素带有定位的父级元素，如果父级都没有定位则返回bodyelement.offsetTop     返回元素相对带有定位父元素是上方的偏移element.offsetLeft    返回元素相对带有定位父元素左边框的偏移element.offsetWidth   返回自身包括padding、边框、内容区的宽度，返回数值不带单位element.offsetHeight  返回自身包括padding、边框、内容区的宽度，返回数值不带单位</code></pre><h2 id="offset和style的区别"><a href="#offset和style的区别" class="headerlink" title="offset和style的区别"></a>offset和style的区别</h2><p><strong>offset</strong></p><ul><li>offset可以得到任意表中的样式值</li><li>offset系列获得的数值是没有单位的</li><li>offsetWidth包含padding+border+width</li><li>offsetWidth等属性是只读属性，只能获取不能赋值</li><li>想要获取元素大小位置，用offset更合适</li></ul><p><strong>style</strong></p><ul><li>style只能获取到行内样式表中的元素值</li><li>style.width获取的是带有单位的字符串</li><li>style.width不包含padding+border</li><li>style.width是可读写属性，既能读取又能赋值</li><li>想要给元素更改值，用style才能更改</li></ul><h1 id="元素可视区client系列"><a href="#元素可视区client系列" class="headerlink" title="元素可视区client系列"></a>元素可视区client系列</h1><p>client翻译过来就是客户端，使用client系列相关的属性来获取元素可视区的相关信息。通过client系列的相关属性可以动态的得到该元素的边框大小、元素大小等。 <strong>常用于获取元素的大小</strong></p><h2 id="client系列属性"><a href="#client系列属性" class="headerlink" title="client系列属性"></a>client系列属性</h2><pre><code>element.clientTop    返回元素上边框大小element.clientLeft   返回元素左边框大小element.clientWidth  返回自身包括padding、内容区的宽度，不含边框，返回数值不带单位element.clientHeight 返回自身包括padding、内容区的高度，不含边框，返回数值不带单位</code></pre><h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><p>立即执行函数(funcation(){})()<br>主要作用：创建一个独立的作用域</p><pre><code>    // 1.立即执行函数:不需要调用，立马能够自己执行的函数    // 2.写法    // (function () &#123; &#125;)() 或者 (function()&#123;&#125;())    (function (a, b) &#123;        console.log(a + b);    &#125;)(1, 2);//第二个括号可以看做是调用函数    (function sum(a, b) &#123;        console.log(a + b);    &#125;(2, 3));    // 3.立即执行函数最大的作用就是 独立创建了一个作用域，里面的所有变量都是局部变量，不会有命名冲突</code></pre><h1 id="元素滚动scroll系列"><a href="#元素滚动scroll系列" class="headerlink" title="元素滚动scroll系列"></a>元素滚动scroll系列</h1><p>scroll翻译过来就是滚动，使用scroll系列的相关属性可以动态的得到该元素的大小、滚动距离等。 <strong>常用于获取元素的滚动距离，页面滚动距离通过window.pageXOffset获得</strong></p><h2 id="scroll系列属性"><a href="#scroll系列属性" class="headerlink" title="scroll系列属性"></a>scroll系列属性</h2><pre><code>element.scrollTop    返回被卷去的上侧距离，返回数值不带单位element.scrollLeft   返回被卷去的左侧距离，返回数值不带单位element.scrollWidth  返回自身实际的宽度，不含边框，返回数值不带单位element.scrollHeight 返回自身实际的高度，不含边框，返回数值不带单位</code></pre><h2 id="页面被卷去的头部"><a href="#页面被卷去的头部" class="headerlink" title="页面被卷去的头部"></a>页面被卷去的头部</h2><p>如果浏览器的高（宽）不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏的高度称之为<strong>页面被卷去的头部</strong>。滚动条在滚动时会触发onscroll事件。</p><h1 id="mouseenter和mouseover的区别"><a href="#mouseenter和mouseover的区别" class="headerlink" title="mouseenter和mouseover的区别"></a>mouseenter和mouseover的区别</h1><p><strong>mouseenter鼠标事件</strong></p><ul><li>mouseover鼠标经过自身盒子会触发，经过子盒子还会触发。因为事件冒泡</li><li>mouseenter和mouseleave鼠标经过自身盒子会触发，经过子盒子不会触发。因为事件不冒泡</li></ul><h1 id="动画函数封装"><a href="#动画函数封装" class="headerlink" title="动画函数封装"></a>动画函数封装</h1><h2 id="动画实现原理"><a href="#动画实现原理" class="headerlink" title="动画实现原理"></a>动画实现原理</h2><p><strong>核心原理：通过定时器setInterval()不断移动盒子位置</strong></p><p>实现步骤：</p><ol><li>获取当前盒子位置</li><li>让当前盒子位置加1个移动距离</li><li>利用定时器不断重复这个操作</li><li>加一个定时器结束条件</li><li><strong>注意此元素需要添加定位，才能使用element,stykle.left</strong></li></ol><h2 id="动画函数简单封装"><a href="#动画函数简单封装" class="headerlink" title="动画函数简单封装"></a>动画函数简单封装</h2><p><strong>注意函数需要传递2个参数，动画对象和移动到的距离，并给不同的元素添加不同的定时器</strong></p><pre><code>    function animate(obj, target) &#123;        clearInterval(obj.timer);        obj.timer = setInterval(function () &#123;             var step = (target - obj.offsetLeft) / 10;            step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);            obj.style.left = obj.offsetLeft + step + &#39;px&#39;            if (obj.offsetLeft == target) &#123;                clearInterval(obj.timer);                                 &#125;            &#125;        &#125;, 30)    &#125;</code></pre><h2 id="缓动动画原理"><a href="#缓动动画原理" class="headerlink" title="缓动动画原理##"></a>缓动动画原理##</h2><p>缓动动画就是让元素运动速度有所变化，最常见的就是让速度慢慢停下来。</p><p>思路：</p><ol><li><p>让盒子每次移动的距离慢慢变小，速度就会慢慢降下来。</p></li><li><p>核心算法： （目标值 - 现在的位置）&#x2F; 10 作为每次移动的距离步长</p></li><li><p>停止条件是：让盒子当前位置等于目标位置就停止定时器</p><pre><code> var step = (target - obj.offsetLeft) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); obj.style.left = obj.offsetLeft + step + &#39;px&#39;</code></pre></li></ol><h2 id="动画函数添加回调函数"><a href="#动画函数添加回调函数" class="headerlink" title="动画函数添加回调函数"></a>动画函数添加回调函数</h2><p>回调函数原理：函数可以作为一个参数。将这个函数作为一个参数传到另一个函数里面，当那个函数执行完之后，再去执行传进去的这个函数，这个过程叫做回调。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 简单动画函数封装 object目标对象 tarjet目标位置</span><br><span class="line">   // 给不同的动画元素指定了不同的定时器</span><br><span class="line">   function animate(obj, target, callback) &#123;</span><br><span class="line">       clearInterval(obj.timer);</span><br><span class="line">       obj.timer = setInterval(function () &#123;</span><br><span class="line">           // div.style.left = div.offsetLeft + 1 + &#x27;px&#x27;;</span><br><span class="line">           // obj.style.left = obj.offsetLeft + (target - obj.offsetLeft) / 10 + &#x27;px&#x27;; </span><br><span class="line">           var step = (target - obj.offsetLeft) / 10;</span><br><span class="line">           step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);</span><br><span class="line">           obj.style.left = obj.offsetLeft + step + &#x27;px&#x27;</span><br><span class="line">           if (obj.offsetLeft == target) &#123;</span><br><span class="line">               clearInterval(obj.timer);</span><br><span class="line">               //回调函数卸载定时器结束里面</span><br><span class="line">               if (callback) &#123;</span><br><span class="line">                   //调用函数</span><br><span class="line">                   callback();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, 30)</span><br><span class="line">   &#125;</span><br><span class="line">   animate(div, 500, red)</span><br><span class="line">   // 背景变色</span><br><span class="line">   function red() &#123;</span><br><span class="line">       div.style.backgroundColor = &#x27;red&#x27;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="动画函数单独放到JS文件里，需要的时候引用"><a href="#动画函数单独放到JS文件里，需要的时候引用" class="headerlink" title="动画函数单独放到JS文件里，需要的时候引用"></a>动画函数单独放到JS文件里，需要的时候引用</h2>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> JS </tag>
            
            <tag> 网页特效 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BOM浏览器对象模型</title>
      <link href="/post/de3efe0d.html"/>
      <url>/post/de3efe0d.html</url>
      
        <content type="html"><![CDATA[<h1 id="BOM浏览器对象模型"><a href="#BOM浏览器对象模型" class="headerlink" title="BOM浏览器对象模型"></a>BOM浏览器对象模型</h1><p>学习目标</p><ul><li>能够说出什么是BOM</li><li>能够知道浏览器的顶级对象window</li><li>能够写出页面加载事件以及注意事</li><li>能都写出两种定时器函数并说出区别</li><li>能够说出JS的执行机制</li><li>能够使用location对象完成页面之间的跳转</li><li>能够知晓navigator对象涉及的属性</li><li>能够使用history提供的方法实现页面的刷新</li></ul><h2 id="BOM概述"><a href="#BOM概述" class="headerlink" title="BOM概述"></a>BOM概述</h2><h4 id="什么是BOM"><a href="#什么是BOM" class="headerlink" title="什么是BOM"></a>什么是BOM</h4><p>BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器交互的对象，其核心对象是window。<br>BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。</p><h4 id="BOM的构成"><a href="#BOM的构成" class="headerlink" title="BOM的构成"></a>BOM的构成</h4><p>window对象是浏览器的顶级对象，它具有双重角色</p><ol><li>它是JS访问浏览器窗口的一个接口</li><li>它是一个全局对象。定义在全局作用域中的变量，函数都会变成window对象的属性和方法，在调用的时候可以省略window<br>document\location\navigator\history</li></ol><h2 id="window对象的常见事件"><a href="#window对象的常见事件" class="headerlink" title="window对象的常见事件"></a>window对象的常见事件</h2><h4 id="窗口加载事件"><a href="#窗口加载事件" class="headerlink" title="窗口加载事件"></a>窗口加载事件</h4><pre><code>doument.addEventlistener(&#39;load&#39;,funcatoon()&#123;&#125;);</code></pre><p>load等页面全部加载完毕，包含页面dom元素、图片、css等</p><pre><code>doument.addEventlistener(&#39;DOMContentLoaded&#39;,funcatoon()&#123;&#125;);</code></pre><p>DOMContentLoaded是dom加载完毕，不包含页面dom元素、图片、css等</p><h4 id="调整窗口大小事件"><a href="#调整窗口大小事件" class="headerlink" title="调整窗口大小事件"></a>调整窗口大小事件</h4><pre><code>window.onresize = funcatuion()&#123;&#125;;window.addEventListener(&quot;resize&quot;,funcation()&#123;&#125;);</code></pre><p>window.onresize是窗口大小加载事件，当触发时就调用处理函数<br>注意：</p><ol><li>只要窗口大小发生像素变化，就会触发这个事件</li><li>经常利用这个事件完成响应式布局。window.innerWidth当前屏幕的宽度</li></ol><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h4 id="两种定时器"><a href="#两种定时器" class="headerlink" title="两种定时器"></a>两种定时器</h4><ul><li>setTimeout()</li><li>setInterval()</li></ul><h3 id="setTimeout-定时器"><a href="#setTimeout-定时器" class="headerlink" title="setTimeout()定时器"></a>setTimeout()定时器</h3><pre><code>window.setTimeout(调用函数，[延迟的毫秒数]);</code></pre><p>setTimeout()这个调用函数也称为<strong>回调函数</strong></p><ol><li>window在调用时可省略</li><li>延迟时间单位是毫秒，可以省略，默认是0</li><li>调用函数可以直接写函数或函数名</li><li>页面中可能有许多定时器，可以给定时器加标识符（名字）</li></ol><h4 id="停止setTimeout-定时器"><a href="#停止setTimeout-定时器" class="headerlink" title="停止setTimeout()定时器"></a>停止setTimeout()定时器</h4><pre><code>window.clearTimeout(timeoutId);</code></pre><h3 id="setInterval-定时器"><a href="#setInterval-定时器" class="headerlink" title="setInterval()定时器"></a>setInterval()定时器</h3><pre><code>window.setInterval(调用函数，[延迟的毫秒数]);</code></pre><p>setInterval()方法重复调用一个函数，每隔这个时间，就去调用一次回调函数</p><h4 id="停止setInterval-定时器"><a href="#停止setInterval-定时器" class="headerlink" title="停止setInterval()定时器"></a>停止setInterval()定时器</h4><pre><code>window.clearInterval(timeoutId);</code></pre><h2 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h2><ol><li>先执行同步栈中的同步任务</li><li>异步任务（回调函数）放入任务队列中</li><li>一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行</li></ol><h3 id="JS是单线程"><a href="#JS是单线程" class="headerlink" title="JS是单线程"></a>JS是单线程</h3><p>JS语言最大的特点之一就是单线程，同一时间只能做一件事。</p><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>前一个任务完成后执行后一个任务，程序的执行顺序欲任务的排列顺序一致。</p><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>做一个任务的同时可以做其他任务。</p><p>JS的异步是通过回调函数实现的，一般而言有一下三种类型：</p><ol><li>普通事件，如click、resize等</li><li>资源加载，如load、error等</li><li>定时器，包括setInterval、setTimeOut等</li></ol><p>本质区别：<strong>流水线上各个程序执行顺序不同</strong></p><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><h3 id="什么是location对象"><a href="#什么是location对象" class="headerlink" title="什么是location对象"></a>什么是location对象</h3><p>window对象提供了一个location属性用于获取或设置窗体的URL，并且可以用于解析URL。</p><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>统一资源定位符（Uniform Resource Locator,url）是互联网上标准资源的地址。互联网上每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器该怎么处理它</p><h3 id="location对象的方法"><a href="#location对象的方法" class="headerlink" title="location对象的方法"></a>location对象的方法</h3><pre><code>location.assign()  跟href一样，可以跳转页面location.replace() 替换当前页面，因为不记录历史，所以不能后退页面location.reload() 重新加载页面，相当于刷新按钮</code></pre><h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><p>navigator对象包含有关浏览器的信息，有很多属性，最常用的是userAgent，该属性可以返回由客户机发送服务器的user-agent的头部致值。</p><h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><p>window对象给我们提供了一个history对象，与浏览器历史相互交互。该对象包含用户访问过的URL。</p><pre><code>back()    后退forward() 前进go(参数)  前进后退功能，根据参数前进后退    </code></pre>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> BOM </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/post/5c2fafc7.html"/>
      <url>/post/5c2fafc7.html</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/idnex.html"/>
      <url>/about/idnex.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/music/idnex.html"/>
      <url>/music/idnex.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/movie/idnex.html"/>
      <url>/movie/idnex.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
